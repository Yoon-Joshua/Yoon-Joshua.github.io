<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>翻译 Ray Tracing In Vulkan | 爬行者巢穴</title><meta name="author" content="Yoon Joshua"><meta name="copyright" content="Yoon Joshua"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="原文链接：Ray Tracing In Vulkan - Khronos Blog 作者：Daniel Koch, NVIDIA, Vulkan Ray Tracing TSG Chair, @booner_k Tobias Hector, AMD, @TobskiHectov Joshua Barczak, Intel, @JoshuaBarczak Eric Werness, NVIDIA">
<meta property="og:type" content="article">
<meta property="og:title" content="翻译 Ray Tracing In Vulkan">
<meta property="og:url" content="http://yoon-joshua.github.io/2023/09/12/ray-tracing-in-vulkan/index.html">
<meta property="og:site_name" content="爬行者巢穴">
<meta property="og:description" content="原文链接：Ray Tracing In Vulkan - Khronos Blog 作者：Daniel Koch, NVIDIA, Vulkan Ray Tracing TSG Chair, @booner_k Tobias Hector, AMD, @TobskiHectov Joshua Barczak, Intel, @JoshuaBarczak Eric Werness, NVIDIA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoon-joshua.github.io/img/cover/ray-tracing-in-vulkan.png">
<meta property="article:published_time" content="2023-09-12T15:14:02.000Z">
<meta property="article:modified_time" content="2023-09-12T15:32:20.140Z">
<meta property="article:author" content="Yoon Joshua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoon-joshua.github.io/img/cover/ray-tracing-in-vulkan.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoon-joshua.github.io/2023/09/12/ray-tracing-in-vulkan/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '翻译 Ray Tracing In Vulkan',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-12 23:32:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/ray-tracing-in-vulkan.png')"><nav id="nav"><span id="blog-info"><a href="/" title="爬行者巢穴"><span class="site-name">爬行者巢穴</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">翻译 Ray Tracing In Vulkan</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-12T15:14:02.000Z" title="发表于 2023-09-12 23:14:02">2023-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-12T15:32:20.140Z" title="更新于 2023-09-12 23:32:20">2023-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Vulkan/">Vulkan</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.khronos.org/blog/ray-tracing-in-vulkan#raytracing1">Ray Tracing In Vulkan - Khronos Blog</a></p>
<p>作者：Daniel Koch, NVIDIA, Vulkan Ray Tracing TSG Chair, <a target="_blank" rel="noopener" href="https://twitter.com/booner_k">@booner_k</a><br>
Tobias Hector, AMD, <a target="_blank" rel="noopener" href="https://twitter.com/TobskiHectov">@TobskiHectov</a><br>
Joshua Barczak, Intel, <a target="_blank" rel="noopener" href="https://twitter.com/JoshuaBarczak">@JoshuaBarczak</a><br>
Eric Werness, NVIDIA <a target="_blank" rel="noopener" href="https://www.khronos.org/news/tags/tag/vulkan">vulkan</a>, <a target="_blank" rel="noopener" href="https://www.khronos.org/news/tags/tag/raytracing">raytracing</a></p>
<p>最后更新时间：2020年12月15日</p>
</blockquote>
<h1>概览</h1>
<p>Khronos Vulkan Ray Tracing Task Sub Group 已经开发并且发布了一套扩展，这些扩展将光线追踪功能无缝融合到现有的Vulkan框架中。这篇博客总结了 Vulkan 的光追扩展是怎样被开发的，阐述了开发者如何使用这些扩展，来将光追功能引入他们自己的应用中。</p>
<p>光线追踪TSG成立于2018年初，其任务是为Vulkan带来一个紧密集成的、跨供应商的光线追踪解决方案。2020年3月，发布了临时光线追踪扩展，以收集公众对这些扩展的最终设计的审查和意见。2020年11月23日，最终规范 <a target="_blank" rel="noopener" href="https://www.khronos.org/blog/vulkan-ray-tracing-final-specification-release">发布</a> 。2020年12月15日，<a target="_blank" rel="noopener" href="https://vulkan.lunarg.com/sdk/home">Vulkan 1.2.162.0 SDK</a>已<a target="_blank" rel="noopener" href="https://www.khronos.org/news/press/vulkan-sdk-tools-and-drivers-are-ray-tracing-ready">宣布</a>，包含了对这些扩展的支持，使开发人员能够轻松地将 Vulkan 光线追踪集成到他们的应用程序中。</p>
<p>TSG收到了一些来自IHV的设计贡献，并审查了ISV和IHV的要求。光线跟踪的实时技术仍在积极研究中，因此Vulkan光线跟踪的第一个版本旨在提供一个有效的框架，同时为未来的发展奠定可扩展的基础。</p>
<p>一个总体设计目标是为光线跟踪加速提供一个单一的、一致的跨平台和多供应商框架，可以轻松地与现有的Vulkan API功能一起使用。我们使框架的这一部分为可选的，以实现符合Vulkan哲学的部署灵活性。对于第一个版本，我们的主要目标是暴露现代桌面硬件的全部功能。</p>
<p>ISV也非常清楚——对于那些使用了当代专有API（例如NVIDIA OptiX或Microsoft DirectX Raytracing）的内容，我们需要使它们可轻松移植到Vulkan。因此，我们使用了熟悉的整体架构，包括重新使用HLSL着色器，同时还引入了新的功能和实现的灵活性。</p>
<p>Vulkan光线跟踪的一个关键用例是游戏中的实时光线跟踪，通常使用光栅化场景和一些光线跟踪方面的混合组合。一些示例包括跟踪主光线后的光栅化后处理、使用光线跟踪生成阴影贴图，以及与其他系统任务异步的动态灯光烘焙。请参见图1和图2，以获取在《德军总部：年轻血液》中使用Vulkan进行混合渲染的示例。</p>
<p>Vulkan光线跟踪还可以用于加速离线生产渲染和创意工具，例如离线灯光贴图烘焙。还有许多其他创新技术可以利用加速光线跟踪框架，包括非渲染技术。我们期待着看到您如何使用这些扩展！</p>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-ray-tracing-in-vulkan-figure-1.jpg" alt="img"></p>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-ray-tracing-in-vulkan-figure-2.jpg" alt="img"></p>
<p>请注意金属墙、穿过门口的地板和房间内窗户上的反射有所改善。它还改善了场景中的整体照明，并消除了门口侧面和地板上的照明伪影。</p>
<h1>引言——Vulkan 光线追踪扩展</h1>
<p>Vulkan 的光线追踪功能由若干Vulkan、SPIR-V和GLSL的扩展组成。</p>
<ul>
<li>Vulkan扩展规范
<ul>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_acceleration_structure.html">VK_KHR_acceleration_structure</a></li>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_ray_tracing_pipeline.html">VK_KHR_ray_tracing_pipeline</a></li>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_ray_query.html">VK_KHR_ray_query</a></li>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_pipeline_library.html">VK_KHR_pipeline_library</a></li>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_deferred_host_operations.html">VK_KHR_deferred_host_operations</a></li>
</ul>
</li>
<li>SPIR-V扩展规范
<ul>
<li><a target="_blank" rel="noopener" href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/KHR/SPV_KHR_ray_tracing.html">SPV_KHR_ray_tracing</a></li>
<li><a target="_blank" rel="noopener" href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/KHR/SPV_KHR_ray_query.html">SPV_KHR_ray_query</a></li>
</ul>
</li>
<li>GLSL扩展规范
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt">GLSL_EXT_ray_tracing</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_query.txt">GLSL_EXT_ray_query</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_flags_primitive_culling.txt">GLSL_EXT_ray_flags_primitive_culling</a></li>
</ul>
</li>
</ul>
<p>3个基本的Vulkan扩展是</p>
<ul>
<li><code>VK_KHR_acceleration_structure</code> - 提供了构建和管理加速结构的功能</li>
<li><code>VK_KHR_ray_tracing_pipeline</code> - 提供了光线追踪着色器阶段和光线追踪管线</li>
<li><code>VK_KHR_ray_query</code> - 为所有着色器阶段提供光线查询内部函数。</li>
</ul>
<p>其中一些功能是可选的，所以一定要检查驱动程序上支持的功能和特性！</p>
<p><code>VK_KHR_acceleration_structure</code>扩展为加速功能提供了公共的基础，加速功能被<code>VK_KHR_ray_tracing_pipeline</code>和<code>VK_KHR_ray_query</code> 所使用。扩展<code>VK_KHR_acceleration_structure</code>的特性由结构体<a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html">VkPhysicalDeviceAccelerationStructureFeaturesKHR</a> 描述：</p>
<blockquote>
<p>译者注：implementation译为“实现”，指的是显卡厂商对Vulkan接口的硬件实现，可以等同于“设备”或“显卡”的意思。</p>
</blockquote>
<ul>
<li>
<p><code>accelerationStructure</code>表示该实现是否支持加速结构功能。所有支持此扩展的实现都要求有这个特性。</p>
</li>
<li>
<p><code>accelerationStructureCaptureReplay</code> 表示该实现是否支持为trace capture and replay保存和重用加速结构的设备地址。这个可选的功能旨在被<strong>工具</strong>使用，而不是被<strong>应用</strong>直接使用。</p>
</li>
<li>
<p><code>accelerationStructureIndirectBuild</code> 表示该实现是否支持间接加速结构的构建命令（<code>vkCmdBuildAccelerationStructuresIndirectKHR</code>）。</p>
</li>
<li>
<p><code>accelerationStructureHostCommands</code> 表示该实现是否支持主机端的加速结构命令（<code>vkBuildAccelerationStructuresKHR</code>, <code>vkCopyAccelerationStructureKHR</code>, <code>vkCopyAccelerationStructureToMemoryKHR</code>, <code>vkCopyMemoryToAccelerationStructureKHR,</code> 和 <code>vkWriteAccelerationStructuresPropertiesKHR</code>）。这些基于CPU的命令是可选的，但是相应的设备（GPU）端的命令版本永远都是被支持的。</p>
</li>
<li>
<p><code>descriptorBindingAccelerationStructureUpdateAfterBind</code> 表示该实现是否支持在描述符集绑定之后更新加速结构描述符。如果这个特性没有被启用， <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> 必不能和<code>VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</code>一起使用。</p>
</li>
</ul>
<p>值得强调的是，这个扩展也要求设备支持来自Vulkan 1.2的<code>descriptorIndexing</code>和<code>bufferDeviceAddress</code>特性。Vulkan 1.1和<code>VK_KHR_spirv_1_4</code>也要求被支持。</p>
<p>扩展 <code>VK_KHR_ray_tracing_pipeline</code> 提供的特性由结构体 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html">VkPhysicalDeviceRayTracingPipelineFeaturesKHR</a> 描述：</p>
<ul>
<li>
<p><code>rayTracingPipeline</code> 表示该实现是否支持光线追踪管线的功能，包括光线追踪着色器阶段和管线，以及<code>SPV_KHR_ray_tracing</code> SPIR-V 扩展。所有支持该扩展的实现都必须支持这个特性。</p>
</li>
<li>
<p><code>rayTracingPipelineShaderGroupHandleCaptureReplay</code> 表示该实现是否支持为trace capture and replay保存和重用着色器组的句柄。这个可选的功能旨在被<strong>工具</strong>使用，而不是被<strong>应用</strong>直接使用。</p>
</li>
<li>
<p><code>rayTracingPipelineShaderGroupHandleCaptureReplayMixed</code> 指示实现是否支持重用任意混合的着色器组句柄以及创建不重用的着色器组手柄。如果此值为 <code>VK_FALSE</code> ，则在创建任何未重用的控制柄之前，必须指定所有重用的着色器组控制柄。</p>
</li>
<li>
<p><code>rayTracingPipelineTraceRaysIndirect</code> 表示该实现是否支持间接光线追踪命令，例如 <code>vkCmdTraceRaysIndirectKHR</code> 。这个特性必须被支持。</p>
</li>
<li>
<p><code>rayTraversalPrimitiveCulling</code> 表示该实现是否支持在光线遍历过程中用于图元剔除的 <code>SkipTrianglesKHR</code> 和 <code>SkipAABBsKHR</code> 光线标志。如果 <code>VK_KHR_ray_query</code> 被支持的话，这个特性就必须被支持。在GLSL中，这些是通过使用 <code>GLSL_EXT_ray_flags_primitive_culling</code> 扩展指定 <code>primitive_culling</code> 布局来启用的。</p>
</li>
</ul>
<p><code>VK_KHR_ray_query</code> 扩展只提供一个特性，这个特性由结构体<a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayQueryFeaturesKHR.html">VkPhysicalDeviceRayQueryFeaturesKHR</a>描述：</p>
<ul>
<li><code>rayQuery</code> 表示该实现是否支持，由名为 <code>SPV_KHR_ray_query</code> 的SPIR-V扩展提供的，在所有着色器阶段（包括光线追踪管线）可用的，光线查询功能。如果硬件支持此扩展，就必须支持此特性。</li>
</ul>
<p>这些扩展还添加了许多可查询属性。它们由 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceAccelerationStructurePropertiesKHR.html">VkPhysicalDeviceAccelerationStructurePropertyKHR</a> 和<a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingPipelinePropertiesKHR.html">VkPhysicalDeviceRayTracingPipelinePropertiesKHR</a> 结构描述。这里的一些值得注意的事项，着色器标头的大小（<code>shaderGroupHandleSize</code>）要求恰好为32，而最大递归深度（<code>maxRayRecursionDepth</code>）只要求为1。</p>
<p>我们添加了两个附加扩展，作为附加功能的构建块。这些扩展添加了基础设施，但不能单独启用功能。未来的扩展可能会在API的其他领域建立在这些扩展的基础上，但在这一点上，它们只允许将此功能用于光线追踪。<a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_KHR_deferred_host_operations">VK_KHR_deferred_host_operations</a> 允许将昂贵的驱动程序操作卸载到应用程序管理的CPU线程池，这可以使工作在后台线程上完成或在多个核心之间并行。通过光线追踪，这可以用于光线追踪管线编译或基于CPU的加速结构构建。<a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_KHR_pipeline_library">VK_KHR_pipeline_library</a>提供了提供一组可以链接到管线中的着色器的能力。使用光线追踪，它在增量构建光线追踪管线时非常有用。</p>
<p>与光线追踪扩展一起使用的着色器作为SPIR-V二进制文件提供给API，该二进制文件使用两个新的SPIR-V扩展：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/KHR/SPV_KHR_ray_tracing.html">SPV_KHR_ray_tracing</a> 添加了对光线追踪管线着色器阶段和指令的支持</li>
<li><a target="_blank" rel="noopener" href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/KHR/SPV_KHR_ray_query.html">SPV_KHR_ray_query</a> 添加了对光线查询着色器指令的支持</li>
</ul>
<p>开发人员可以使用GLSL或HLSL生成这些二进制文件。对于GLSL，有三个新的GLSL扩展：<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt">GLSL_EXT_ray_tracing</a>，<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_query.txt">GLSL_EXT_ray_query</a>，和<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_flags_primitive_culling.txt">GLSL_EXT_ray_flags_primitive_culling</a>，它们得到了开源的 <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/glslang/">glslang</a> 编译器的支持。HLSL也有 <a target="_blank" rel="noopener" href="https://github.com/microsoft/DirectXShaderCompiler">DXC</a> 的支持，DXC 是 Microsoft 的开源HLSL编译器，允许使用Microsoft定义的语法只需<a target="_blank" rel="noopener" href="https://developer.nvidia.com/blog/bringing-hlsl-ray-tracing-to-vulkan/">最少的修改</a>就能在HLSL中编写Vulkan光线追踪着色器。glsland和DXC都包含在<a target="_blank" rel="noopener" href="https://vulkan.lunarg.com/sdk/home">Vulkan SDK</a>中。</p>
<p>本文档的以下部分将详细介绍光线追踪功能，包括创建和使用加速结构、主机和延迟操作、光线遍历、光线追踪管线以及光线查询。</p>
<h1>加速结构</h1>
<p>为了在复杂场景中实现高性能，光线追踪针对基于场景信息构建的优化数据结构（称为加速结构，即AS）执行光线相交。加速结构分为两级层次结构，如下图所示。底层加速结构包含组成场景的自定义几何体的三角形或轴对齐边界框（AABB）。由于每个底层加速结构可以对应于光栅化管道中的多个绘制调用，因此每个底层构建可以采用给定类型的多组几何体。顶层加速结构包含对一组底层加速结构的引用，每个引用都包括该引用的着色和变换信息。</p>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-ray-tracing-in-vulkan-figure-3.jpg" alt="img"></p>
<p>构建任何一种类型的加速结构都会在内存中产生不透明的、由硬件定义的格式。底层加速结构仅用于被顶层加速结构引用。顶层加速结构作为描述符绑定或通过设备地址（通过 <code>vkGetAccelerationStructureDeviceAddressKHR</code> 获得）从着色器访问。</p>
<p>要创建加速结构，应用程序必须首先确定加速结构所需的空间大小。对于构建，加速结构的大小以及构建和更新的暂存缓冲区大小是通过 <code>vkGetAccelerationStructureBuildSizesKHR</code> 命令在 <code>VkAccelerationStructureBuildSizesInfoKHR</code> 结构中获得的。要创建的加速结构的<strong>形状</strong>和<strong>类型</strong>在 <code>VkAccelerationStructureBuildGeometryInfoKHR</code> 结构中进行了描述。这个结构稍后会被用来参与实际的构建，但此时不需要完全填写加速结构参数和几何数据指针（尽管也可以这么做），只需要填写加速结构的类型以及几何类型、数量和最大大小。这些大小尺寸对于任何足够相似的加速结构都是有效的。对于将成为压缩副本目标的加速结构，可以通过 <code>vkCmdWriteAccelerationStructuresPropertiesKHR</code> 命令获得所需的大小。一旦确定了所需的大小，应用程序就会为加速结构（<code>accelerationStructureSize</code>）创建一个 <code>VkBuffer</code> ，并根据构建（<code>buildScratchSize</code>）和更新（<code>updateScratchSize</code>）暂存缓冲区的需要创建其他 <code>VkBuffer</code> 。</p>
<p>接下来，可以使用 <code>vkCreateAccelerationStructureKHR</code> 命令创建 <code>VkAccelerationStructureKHR</code> 对象，该命令创建指定 <code>type</code> 和 <code>size</code> 的加速结构，并将其放置在<code> VkAccelerationStructureCreateInfoKHR</code> 中提供的 <code>buffer</code> 内的 <code>offset</code> 处。与Vulkan中的大多数其他资源不同，缓冲区的指定部分完全为加速结构提供了内存；无需查询额外的内存需求或将内存绑定到加速结构对象。如果需要，可以将多个加速结构放置在同一 <code>VkBuffer</code> 中，前提是加速结构不重叠。</p>
<p>使用<code>vk&#123;Cmd&#125;BuildAccelerationStructuresKHR</code> 来执行构建。对于底层加速结构，三角形的顶点数据或AABB的范围信息是从缓冲区中提取的。顶层加速结构从缓冲区中的结构体中提取每个实例的着色、变换和引用信息。使用具有特殊标志的相同函数来执行对加速结构的更新，此特殊标志指示需要从现有加速结构更新的位置。</p>
<p>因为加速结构内存是一种硬件定义的不透明格式，所以有一组函数可以对加速结构数据执行操作：<code>vk&#123;Cmd&#125;CopyAccelerationStructureKHR</code>，<code>vk&#123;Cmd&#125;CopyAccelerationStructureToMemoryKHR</code>，和<code>vk&#123;Cmd&#125;CopyMemoryToAccelerationStructureKHR</code>。</p>
<p>除了基本的拷贝功能外，这些函数还可以执行受限形式的序列化和反序列化，以保存和恢复具有特定版本兼容性要求的加速结构（请参见<a target="_blank" rel="noopener" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html">vkGetDeviceAccelerationStructureCompatibilityKHR</a>)。</p>
<p>加速结构也可能最终为其保留比所需更多的空间，因此对于大型静态加速结构，减少最终使用的空间量是有益的。应用程序可以使用 <code>vk&#123;Cmd&#125;WriteAccelerationStructuresPropertiesKHR</code> 要查询最终压缩大小，请使用 <code>vk&#123;Cmd&#125;CopyAccelerationStructureKHR</code> 以压缩加速结构。</p>
<h1>主机操作</h1>
<p>加速结构是非常庞大的资源，管理它们需要大量的处理工作。将这项工作与其他渲染工作一起安排在设备上可能很棘手，尤其是在需要主机干预的情况下。Vulkan同时提供主机和设备的加速结构操作变体，使应用程序能够更好地调度这些工作负载。设备变体（<code>vkCmd*AccelerationStructure*KHR</code>）被排入命令缓冲区并在设备时间线上执行，主机变体（<code>vk*Acceleration Structure*KHR </code>）直接在主机时间线上执行。</p>
<h2 id="延迟操作">延迟操作</h2>
<p>在CPU上执行加速结构构建和更新是一种相对容易并行化的工作负载，我们希望能够在Vulkan中利用这一点。应用程序可以在独立的线程上执行独立的命令，但这种方法需要有足够的命令来充分利用机器。它还可能导致负载不平衡，因为某些命令可能比其他命令花费更长的时间。</p>
<p>为了避免这些障碍，我们添加了延迟操作以启用命令内部的并行性：将单个命令的工作分散到多个CPU核心。驱动程序管理的线程池是实现这一点的一种方法，但不符合Vulkan的底层显式哲学。应用程序还运行自己的线程池，最好启用这些线程来执行工作，这样应用程序就可以管理驱动程序工作的执行及其其余负载。</p>
<p>延迟主机操作是围绕“分工”原则设计的。该应用程序负责：</p>
<ul>
<li>设置命令并请求延迟执行。</li>
<li>分配工作线程来执行延迟命令。</li>
<li>通过选择执行哪些任务以及何时执行任务，根据需要设置优先级和CPU预算。</li>
</ul>
<p>驱动程序负责：</p>
<ul>
<li>跟踪延迟命令的执行状态。</li>
<li>实现分布式执行，无论哪种并行结构最适合工作负载（任务、并行循环、依赖关系图、工作队列等）。</li>
</ul>
<p>通过这种方式，应用程序控制工作的分配和优先级，但驱动程序管理低级细节。</p>
<p>为了使用延迟操作，应用程序首先构造一个 <code>VkDeferredOperationKHR</code> 对象，该对象封装了延迟命令的执行状态。该对象在其整个生命周期中将处于两种状态之一（<em>Complete</em>或<em>Pending</em>），如下图所示。</p>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-raytracing-img-04.png" alt="img"></p>
<p>延迟操作是在 <em>Complete</em> 状态下构造的。应用程序通过向命令传递 <code>VkDeferredOperationKHR</code> 对象来发出命令的延迟请求。如果驱动程序接受延迟请求，则延迟操作将转换为 <em>Pending</em> 状态。请注意，驱动程序可以自由拒绝请求，而仅仅就地执行命令，这样的话延迟操作就立即变为 <em>Compete</em> 状态。</p>
<p>一旦延迟，操作将不会进行，直到应用程序通过调用 <code>vkDeferredOperationJoinKHR</code> 将线程加入其中。join命令指示驱动程序使用调用线程来处理与给定延迟操作相关联的命令。应用程序可以将任意数量的线程连接到延迟操作，这样做通常会使命令更快地完成。只要至少有一个线程观察到 <code>vkDeferredOperationJoinKHR</code> 中的 <code>VK_SUCCESS</code> 返回值，该操作就会变为 <em>Complete</em> 。请注意，如果有多个线程加入了延迟操作，那么如果 Vulkan 知道加入的线程比它能够利用的线程多，那么它可能会从 join 中提前返回。</p>
<h2 id="用例-Simplified-Compaction">用例: Simplified Compaction</h2>
<p>压缩是减少光线追踪加速结构的内存占用的一个非常重要的优化。压缩的加速结构的构建如下：</p>
<ol>
<li>确定加速结构在最坏情况下的内存需求</li>
<li>分配设备内存</li>
<li>构建加速结构</li>
<li>确定压缩后的内存大小</li>
<li>GPU同步</li>
<li>分配设备内存</li>
<li>执行压缩拷贝</li>
</ol>
<p>为了被压缩的加速结构分配内存，应用程序需要知道其大小。为了确定大小，它需要为步骤3和4提交一个命令缓冲区，并等待它完成。</p>
<p>这个细节在经验丰富的引擎开发人员心中敲响了警钟。如果单纯地这样做，这种主机/设备握手会严重降低性能。如果做得好，它是一个重要的复杂性来源，并可能导致应用程序设备内存占用的峰值，因为未压缩的加速结构需要在设备内存中至少存在一帧。</p>
<p>主机构建允许我们消除这两个缺点。使用主机构建，我们可以通过在主机上执行初始构建，然后执行从主机内存到设备内存的压缩拷贝来实现压缩。这个副本仍然需要监控，以便应用程序可以恢复主机内存，这是一个更熟悉的方法，引擎已经用这种方法实现了将纹理和几何数据上传到设备。</p>
<h2 id="用例-Load-Balancing">用例: Load Balancing</h2>
<p>主机的加速结构构的建提供了通过利用闲置CPU来提高性能的机会。考虑一个游戏中的假设情况：</p>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-ray-tracing-in-vulkan-figure-5.png" alt="img"></p>
<p>在上图中，加速结构的构建和更新是在设备上实现的，但应用程序有相当多的CPU空闲时间。将这些操作移动到主机允许CPU与前一帧的渲染并行地执行下一帧的加速结构工作。这可以提高吞吐量，即使CPU需要更多的时钟时间来执行相同的任务，如下图所示。</p>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-ray-tracing-in-vulkan-figure-6.png" alt="img"></p>
<h1>光线遍历</h1>
<p>在Vulkan中，利用加速结构进行光线追踪需要经过多个逻辑阶段，从而在追踪光线的方式上具有一定的灵活性。候选交点最初是纯粹基于它们的几何特性找到的——光线与加速结构中描述的几何对象是否存在交点？</p>
<p>在Vulkan中，交点测试是“水密”的——这意味着对于加速度结构中描述的单个几何对象，光线不能通过三角形之间的间隙泄漏，并且不能报告同一位置的不同三角形的多次命中。但是，对于碰巧邻接的相邻对象，这并不能保证，但这意味着单个模型中不会有洞，也不会过度着色。</p>
<p>一旦找到一个候选点，在交点被确认之前就会进行一系列的剔除操作。这些剔除操作基于用于遍历的标志和加速结构的属性来丢弃候选点；这些细节在 <em>Vulkan Specification</em> 中。剩余的不透明三角形候选点被确认为有效的交点；而AABB和非不透明三角形需要着色器代码以编程方式确定是否被命中。</p>
<p>遍历继续进行，直到找到所有可能的候选点，并且确认或丢弃它们。并且确定最接近的命中。遍历也可以提前结束，以避免不必要的处理。这可以用于检测遮挡，或者在某些情况下作为优化。</p>
<p>在Vulkan中，追踪光线并得到遍历结果可以通过两种机制做到：<a target="_blank" rel="noopener" href="https://www.khronos.org/blog/ray-tracing-in-vulkan#blog_Ray_Tracing_Pipelines">光线追踪管线</a> 和<a target="_blank" rel="noopener" href="https://www.khronos.org/blog/ray-tracing-in-vulkan#blog_Ray_Queries">光线查询</a>（见下图）：</p>
<ul>
<li>光线查询提供了对任何着色器阶段中光线遍历逻辑的直接访问，允许将它们插入现有着色器中，并增强这些着色器的效果。</li>
<li>光线追踪管线提供了一种具有动态着色器选择的专用光线跟踪机制，使场景中使用的材质和可编程求交逻辑具有显著的灵活性。</li>
</ul>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-ray-tracing-in-vulkan-figure-7.jpg" alt="img"></p>
<h1>光线追踪管线</h1>
<p>应用程序可以将特定着色器与场景中的特定对象相关联，为这些对象定义材质参数和求交逻辑等内容。随着遍历的进行，当光线与对象相交时，实现会自动执行关联的着色器（请参见下图）。光线追踪管线类似于Vulkan中的图形管线，但增加了管理明显更多着色器以及将对特定着色器的引用放入内存的功能。</p>
<p>光线追踪管线工作是使用<code>vkCmdTraceRaysKHR</code>与当前绑定的光线追踪管线一起启动的。该命令调用应用程序定义的一组光线生成线程，这些线程可以从着色器调用<code>traceRaysEXT()</code>，开始对指定的加速结构进行遍历。在遍历过程中，如果追踪和加速结构需要， intersection shader 和 any hit shader 中的着色器代码可以控制遍历的进行方式。遍历完成后，将调用 miss shader 或 closest-hit shader 。</p>
<p>Callable shaders 可以使用相同的着色器选择机制调用，但不在直接遍历的上下文中。</p>
<p>不同的的着色器阶段可以互相传递参数和结果，这利用了所有遍历阶段间的 ray payload 结构体和来自控制遍历的着色器的 ray attribute 结构体。</p>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-raytracing-img-08_1.png" alt="img"></p>
<p>为了使遍历阶段知道在给定的遍历步骤之后调用哪个着色器来控制或响应遍历， Vulkan 使用着色器绑定表（Shader Binding Table，简称 SBT ）。每个着色器条目都包括从给定着色器组（Shader Group）的实现中查询到的着色器组句柄，以及应用程序可以用于实例的特定数据（如缓冲设备地址或描述符索引）的可选着色器缓冲区记录。任何给定着色器的地址都是通过遍历追踪光线API调用的参数、<code>traceRayEXT</code>着色器调用的参数和存储在加速结构中的信息的组合来计算的。</p>
<p>光线追踪管线可以像其他管线类型一样直接创建，但由于光线追踪管线的着色器数量可能比其他管线类型多几个数量级，并且我们可能希望添加着色器，因此扩展添加了另一种机制： pipeline library 。Pipeline library是一种包含状态和着色器的管线，带有一个附加标志，用于指示它不打算直接绑定到 API ，而是打算用作要包含在以后管线中的代码库。 Pipeline library 可以在多个光线追踪管线中使用，从而允许在多个管线中重用着色器编译。光线追踪管线创建可以包括创建中的一组 pipeline library 管线以及一组光线追踪着色器。每个着色器的所有编译状态必须匹配，才能创建兼容的最终管线。除了 pipeline library，<a href="applewebdata://95CD1046-32FE-4C08-8636-14316D80944C#_ouz3o941fnji">deferred host operations</a> 可以用于光线追踪管线的构造，以实现进一步的并行化。</p>
<p>请注意，虽然 pipeline library 是作为单独的扩展公开的，但它们目前仅集成用于光线追踪管线。</p>
<h2 id="光线追踪管线着色器示例-GLSL">光线追踪管线着色器示例(GLSL)</h2>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ray generation shader</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"><span class="meta">#extension GL_EXT_ray_tracing : enable</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) rayPayloadEXT <span class="type">vec4</span> payload;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>, set = <span class="number">0</span>) <span class="keyword">uniform</span> accelerationStructureEXT acc;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">1</span>, <span class="keyword">rgba32f</span>) <span class="keyword">uniform</span> <span class="type">image2D</span> img;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">1</span>, set = <span class="number">0</span>) <span class="keyword">uniform</span> rayParams</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> rayOrigin;</span><br><span class="line">    <span class="type">vec3</span> rayDir;</span><br><span class="line">    <span class="type">uint</span> sbtOffset;</span><br><span class="line">    <span class="type">uint</span> sbtStride;</span><br><span class="line">    <span class="type">uint</span> missIndex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    traceRayEXT(acc, gl_RayFlagsOpaqueEXT, <span class="number">0xff</span>, sbtOffset,</span><br><span class="line">                sbtStride, missIndex, rayOrigin, <span class="number">0.0</span>,</span><br><span class="line">                computeDir(rayDir, gl_LaunchIDEXT, gl_LaunchSizeEXT),</span><br><span class="line">                <span class="number">100.0</span>f, <span class="number">0</span> <span class="comment">/* payload */</span>);</span><br><span class="line">    imgColor = payload + <span class="type">vec4</span>(blendColor) ;</span><br><span class="line">    <span class="built_in">imageStore</span>(img, <span class="type">ivec2</span>(gl_LaunchIDEXT), payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closest hit shader</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"><span class="meta">#extension GL_EXT_ray_tracing : enable</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) rayPayloadInEXT <span class="type">vec4</span> payload;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    payload = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Miss shader</span></span><br><span class="line"><span class="meta">#version 460 core</span></span><br><span class="line"><span class="meta">#extension GL_EXT_ray_tracing : enable</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) rayPayloadInEXT <span class="type">vec4</span> payload;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    payload = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>光线查询</h1>
<p>光线查询可用于执行光线遍历，并在任何着色器阶段返回结果。除了需要加速结构外，光线查询仅使用一组新的着色器指令执行。</p>
<p>光线查询使用要查询的加速结构、决定了遍历属性的光线标志、剔除掩码以及要追踪的光线的几何描述进行初始化。</p>
<p>在遍历过程中，着色器可以访问潜在和已提交交点的属性，以及光线查询本身的属性，从而能够根据相交的几何体、相交方式和位置进行复杂的决策（见下图）。</p>
<p><img src="/img/ray-tracing-in-vulkan/2020-blog-raytracing-img-09_1.png" alt="img"></p>
<h2 id="光线查询示例-GLSL">光线查询示例 (GLSL)</h2>
<p>以下是GLSL中光线查询的不完整示例，说明着色器如何使用光线查询来检测给定位置是否处于阴影中。这可以添加到片段着色器中，以提供给照明计算。大多数光线查询的总体结构通常是相似的——初始化，循环进行，然后做出最终决定。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">rayQueryEXT rayQuery;</span><br><span class="line">rayQueryInitializeEXT(rayQuery, accelerationStructure,</span><br><span class="line">                      gl_RayFlagsTerminateOnFirstHitEXT,</span><br><span class="line">                      cullMask, origin, tMin, direction, tMax);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(rayQueryProceedEXT(rayQuery)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rayQueryGetIntersectionTypeEXT(rayQuery, <span class="literal">false</span>) ==</span><br><span class="line">        gl_RayQueryCandidateIntersectionTriangleEXT)</span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// Determine if an opaque triangle hit occurred</span></span><br><span class="line">        <span class="keyword">if</span> (opaqueHit) rayQueryConfirmIntersectionEXT(rayQuery);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rayQueryGetIntersectionTypeEXT(rayQuery, <span class="literal">false</span>) ==</span><br><span class="line">             gl_RayQueryCandidateIntersectionAABBEXT)</span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// Determine if an opaque hit occurred in an AABB</span></span><br><span class="line">        <span class="keyword">if</span> (opaqueHit) rayQueryGenerateIntersectionEXT(rayQuery, ...);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rayQueryGetIntersectionTypeEXT(rayQuery, <span class="literal">true</span>) ==</span><br><span class="line">    gl_RayQueryCommittedIntersectionNoneEXT)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Not shadow!</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Shadow!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Call to Action!</h1>
<p><a target="_blank" rel="noopener" href="https://vulkan.lunarg.com/sdk/home">Vulkan Software Development Kit (SDK)</a> 1.2.162.0及更高版本现在完全支持新的 Vulkan 光线追踪扩展，包括验证层和升级的 GLSL 、 HLSL 和 SPIR-V 着色器工具链的集成。 Khronos 开源 <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Samples/tree/master/samples#basic-ray-tracing">Vulkan Samples</a> 和 <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Guide">Vulkan Guide</a> 已经升级，以展示并阐述光线追踪技术。</p>
<p>包括 Vulkan 光线追踪扩展的 Vulkan 驱动程序现在正在为 AMD 和 NVIDIA 的 GPU 推进，从在Windows和Linux上的 <a target="_blank" rel="noopener" href="https://gpuopen.com/vulkan-ray-tracing-extensions/">AMD Radeon Adrenalin 20.11.3</a> 以及 <a target="_blank" rel="noopener" href="https://news.developer.nvidia.com/vulkan-ray-tracing-production-drivers-and-quake-ii-rtx-cross-vendor-extensions/">适用于GeForce和Quadro的NVIDIA R460驱动程序</a> 开始。Vulkan 光线追踪扩展也将由2021年推出的 Intel Xe-HPG GPU 支持，并通过定期更新驱动程序提供驱动程序支持。</p>
<p>您可能感兴趣的 Vulkan 光线追踪的其他相关材料包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/blog/vulkan-ray-tracing-final-specification-release">Exploring deeper technical details of the Vulkan Ray Tracing specifications</a></li>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/blog/vulkan-ray-tracing-best-practices-for-hybrid-rendering">Best practices for Vulkan hybrid rendering techniques as used in Wolfenstein: Youngblood</a></li>
</ul>
<p>Vulkan 工作组很高兴能够让开发者和内容创作社区使用 Vulkan 光线追踪，我们欢迎任何反馈或问题。这些可以通过 <a target="_blank" rel="noopener" href="https://khr.io/slack">Khronos Developer Slack</a> 和 <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Docs/issues">Vulkan GitHub Issues Tracker</a> 分享。</p>
<p>欢迎来到可移植、跨供应商、跨平台的光线追踪加速时代！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://yoon-joshua.github.io">Yoon Joshua</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoon-joshua.github.io/2023/09/12/ray-tracing-in-vulkan/">http://yoon-joshua.github.io/2023/09/12/ray-tracing-in-vulkan/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoon-joshua.github.io" target="_blank">爬行者巢穴</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/cover/ray-tracing-in-vulkan.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/09/09/real-time-ray-tracing/" title="Real-time Ray Tracing"><img class="cover" src="/img/cover/real-time-ray-tracing.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Real-time Ray Tracing</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yoon Joshua</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:xryin_2000@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">引言——Vulkan 光线追踪扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">加速结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">主机操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">延迟操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B-Simplified-Compaction"><span class="toc-number">4.2.</span> <span class="toc-text">用例: Simplified Compaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B-Load-Balancing"><span class="toc-number">4.3.</span> <span class="toc-text">用例: Load Balancing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">光线遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">光线追踪管线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%AE%A1%E7%BA%BF%E7%9D%80%E8%89%B2%E5%99%A8%E7%A4%BA%E4%BE%8B-GLSL"><span class="toc-number">6.1.</span> <span class="toc-text">光线追踪管线着色器示例(GLSL)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">光线查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E6%9F%A5%E8%AF%A2%E7%A4%BA%E4%BE%8B-GLSL"><span class="toc-number">7.1.</span> <span class="toc-text">光线查询示例 (GLSL)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Call to Action!</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/12/ray-tracing-in-vulkan/" title="翻译 Ray Tracing In Vulkan"><img src="/img/cover/ray-tracing-in-vulkan.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻译 Ray Tracing In Vulkan"/></a><div class="content"><a class="title" href="/2023/09/12/ray-tracing-in-vulkan/" title="翻译 Ray Tracing In Vulkan">翻译 Ray Tracing In Vulkan</a><time datetime="2023-09-12T15:14:02.000Z" title="发表于 2023-09-12 23:14:02">2023-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/09/real-time-ray-tracing/" title="Real-time Ray Tracing"><img src="/img/cover/real-time-ray-tracing.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Real-time Ray Tracing"/></a><div class="content"><a class="title" href="/2023/09/09/real-time-ray-tracing/" title="Real-time Ray Tracing">Real-time Ray Tracing</a><time datetime="2023-09-09T06:17:11.000Z" title="发表于 2023-09-09 14:17:11">2023-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/18/real-time-physically-based-materials/" title="Real-time Physically-Based Materials"><img src="/img/cover/real-time-physically-based-materials.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Real-time Physically-Based Materials"/></a><div class="content"><a class="title" href="/2023/08/18/real-time-physically-based-materials/" title="Real-time Physically-Based Materials">Real-time Physically-Based Materials</a><time datetime="2023-08-18T06:48:14.000Z" title="发表于 2023-08-18 14:48:14">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/11/real-time-global-illumination/" title="Real-time Global Illumination"><img src="/img/cover/real-time-global-illumination.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Real-time Global Illumination"/></a><div class="content"><a class="title" href="/2023/08/11/real-time-global-illumination/" title="Real-time Global Illumination">Real-time Global Illumination</a><time datetime="2023-08-11T07:19:14.000Z" title="发表于 2023-08-11 15:19:14">2023-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/07/real-time-environment-mapping/" title="Real-Time Environment Mapping"><img src="/img/cover/real-time-environment-mapping.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Real-Time Environment Mapping"/></a><div class="content"><a class="title" href="/2023/08/07/real-time-environment-mapping/" title="Real-Time Environment Mapping">Real-Time Environment Mapping</a><time datetime="2023-08-07T06:02:14.000Z" title="发表于 2023-08-07 14:02:14">2023-08-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Yoon Joshua</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>